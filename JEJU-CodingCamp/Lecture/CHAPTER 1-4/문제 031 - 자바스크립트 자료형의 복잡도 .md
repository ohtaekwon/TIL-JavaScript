# _CHAPTER 1-4_

###  :pencil: ​_문제 031 :  자바스크립트 자료형의 복잡도_

다음 배열 내장함수의 시간 복잡도가 O(1)이 아닌 것을 모두 고르시오.

> **1 ) arr[i]**
>
> **2 ) arr.push(5)**
>
> **3 ) arr.slice()**
>
> **4 ) arr.pop()**
>
> **5 ) arr.includes(5)**

<br>

:ballot_box_with_check: **풀이 해석**

`시간복잡도` 란 어떤 알고리즘 문제를 계산할 때 걸리는 시간을 의미한다.

시간복잡도는 비고 표기법으로 표현한다. 문제에 주어진 `O(1)`과 같은 것들이 있는데, 이것은 `'O원'`이라고 읽는다. 이것의 의미는 입력되는 데이터의 크기와 상관없이 이 알고리즘이 문제를 해결하는 속도가 모두 일정할 때 O(1)이라고 표기를 한다. 즉, 보기의 arr의 원소의 개수가 아무리 커져도 메소드들의 작동시간이 일정하게 되면 그것을 `O(1)`이라 한다.

- `1)` , arr의 개수가 아무리 커도 index를 접근하는 것은 다 똑같다.
- `2)`, push() 메소드는 배열 가장 끝에 push 매개변수 값을 집어 넣는 것을 의미한다.
  - arr가 아무리 커도 끝에 추가할 뿐 시간복잡도는 같다.
- `3)` slice() 메소드는 slice의 매개변수만큼 잘라서 새로운 배열을 반환하는 것을 의미한다.
  - _ex) slice(3,6); 3번째 인덱스부터 잘라서 5번째 인덱스까지 잘라내 새로운 배열을 하는 것_
  - 여기서 3과 6이 아닌 3과 9999999999일 때, 시간복잡도는 커진다.
- `4)` pop() 메소드는 배열 가장 끝에 있는 원소를 제거하는 것을 의미한다.
  - 배열이 아무리 커져도 매개변수만큼 끝에만 잘라내면 되기 때문에 시간복잡도는 `O(1)`
- `5)` incluedes() 메소드는 배열안에 매개변수값이 들어있는지 true, false값으로 반환하는 것이다.
  - arr가 클 수 록 즉, 원소의 개수가 많아질 수록 시간복잡도는 O(1)은 아니다.

<br>

---

<br>

### :diamond_shape_with_a_dot_inside: 추가 학습

### :one: 시간복잡도

시간 복잡도란 알고리즘이 수행되는데 소요되는 연산 횟수를 이야기합니다. 그런데 이 연산 횟수라는게 항상 일정하지가 않아요. 예를 들면 아래와 같은 간단한 예를 보면,

```javascript
function sample(arr, no) {
  for(let i=0; i<arr.length; i++) {
    if(arr[i] === no) return i;
  }
}
```

여기서 arr 값이 [1, 2, 3, 4, … 10] 이라고 가정을 했을때, no 값이 1이라면 연산 횟수는 1이 되겠지요? 하지만 no 값이 arr의 마지막 값이라면 연산 횟수는 10이 된다. 

그래서 알고리즘을 평가할때 최선의 경우(Best Case), 평균적인 경우(Average Case), 최악의 경우(Worst Case)로 나눈다.

_위 예의 경우에 최선의 경우는 1, 최악의 경우는 10, 평균의 경우는 5쯤.. 되겠다._

<br>

그러면 평균적인 경우의 값이 가장 의미가 있어 보이지만, 알고리즘이 복잡해질 수록 평균값을 계산하기가 어려워지기 때문에 일반적으로 시간 복잡도는 최악의 경우를 많이 사용한다고 합니다.
그리하여 위 예제의 경우의 시간 복잡도는 2n+1이 되는 데요. 아래에서 살펴보면,
(여기서 n = arr.length)

```javascript

function sample(arr, no) {
  for(let i=0; i<arr.length; i++) { // n + 1 (여기서 + 1은 let i = 1; 을 1번 실행하기 때문입니다.)
    if(arr[i] === no) return i; // n (반복문이 n번 실행되니 여기도 n번 실행된다.)
  }
}
```

위와 같이 총 반복수를 더하면, 시간 복잡도가 2n+1이 됩니다. 그런데 아직 알아보지 않았지만 빅오 표기법으로 표현하면 n의 최고차항만 만겨서 표기하는데요. 왜냐면 n이 엄청 커지면 n+1 같은 건 별로 차이가 없기 때문인데요. 그래서 빅오 표기법으로 표현하면 위 코드의 시간 복잡도는 O(n)이 됩니다.

<br>

<br>

### 출처

---

- https://falsy.me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-1-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/